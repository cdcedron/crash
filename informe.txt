Laboratorio 1 - Crash
Integrantes: Capogrossi Agustín (agustin.capogrossi@mi.unc.edu.ar), Espinosa Bruno (bruno.espinosa@mi.unc.edu.ar)
	El laboratorio presento diversas dificultades, dificultad para comprender algunos de los elementos del TAD pipeline y el TAD scommand asi como dificultades para la implementación de los mismos, principalmente los to_string correspondientes a cada TAD. A su vez la reserva y liberación de memoria resultó otro inconveniente puesto que el código final aun presenta leaks.

	En cuanto al diseño general de los archivos se tomaron algunas decisiones temporales que fueron modificadas poco tiempo despues de empezar el laboratorio. El órden en el que estaban detallados los elementos de los TAD en el archivo command.h generaba un pequeño error, puesto que uno de los assert requería que se cumpliera !scommand_is_empty(const scommand self), pero el mismo estaba declarado por debajo de la función que lo requería por lo que cambiamos su orden ligeramente para sobrellevar ese error. La mayoría de las implementaciones fueron realizadas mediante las funciones de GLib Sequence. Preferimos utilizar esta opción en lugar de Queue pues consideramos que las referencias de sequence eran mas simples de entender y utilizar.

	Algunos cambios mas particulares realizados se dieron en las funciones de set_redir_in/out y get_redir_in/out. En las mismas incluímos inicialmente un condicional que solo permitiera que se estableciera el filename si los redirectores no eran NULL, lo cual era completamente erróneo, ya que si la redirección era NULL no se agregaba el filename y no funcionaba el 50% de las veces. Otro error que cometimos incialmente fue incluir un término extra en el assert, el cual no permitía que el filename fuera NULL, esto provocó errores en el testeo de Redirecciones independientes por lo que fue corregido posteriormente.
	Las funciones to_string fueron originalmente implementadas tomando el primer elemento de self y removiendolo, llamandolo nuevamente de manera recursiva pero la especificación establecía que self era "const" por lo que no debía ser modificado durante la implementación. Debido a esto encontramos una forma de iterar que resulta curiosa. En lugar de utilizar un entero que se mueva entre 0 y el tamaño máximo, utilizamos GSequenceIter, un tipo de datos interno al cual no se le puede sumar numeros enteros. Uno de los comandos internos de GSequence es "g_seguence_next_iter" el cual toma un GSequenceIter y devuelve el siguiente. Gracias a esto pudimos recorrer el scommand transformandolo en strings. Originalmente agregabamos las redirecciones al final de toda la cadena de texto, posteriormente nos dimos cuenta que debíamos agregar "<" y ">" cuando hubiera una redirección y no tendría sentido que esto esté al final. Agregamos dos condiciones que incluían una "<" si la redirección de entrada no era NULL, y ">" cuando la redirección de salida no era NULL. Posteriormente nos dimos cuenta que el g_sequence_get tiene un assert el cual no permite que tome como parámetro el último iter de la secuencia, por lo que al final decidimos recorrer el arreglo eliminando el primer elemento en cada iteración hasta que la secuencia sea vacía.
	En el pipeline_to_string no se presentaron muchas complicaciones, utilizamos la misma estructura que en scommand_to_string, el principal error que cometimos inicialmente es tomar el primer elemento del pipeline, el cual es de tipo scommand y por lo tanto la función no cumplía lo que pedía la especificación, para solucionar esto le aplicamos scommand_to_stiring a cada elemento del pipeline.
	En builtin.h el principal problema fue detectar si lo que se queria usar era un cd o un exit, el método que utilizamos fue una comparación de strings con strcmp de la biblioteca string.h, y lo utilizamos como parámetro del condicional, suponiendo que los valores de retorno eran 1 y 0 como suele ser normalmente, posteriormente nos dimos cuenta que enrealidad retorna 0  si los strings son iguales por lo que modificamos ligeramente el parámetro del condicional para que funcione como corresponde.
	Se presentaron algunos problemas al implementar el chdir, principalmente por que le estábamos dando como argumento el primer elemento de la secuencia, hasta que nos dimos cuenta que el primer argumento es el comando, por lo que en su lugar le dimos el segundo elemento como argumento y el problema se  solucionó.
	En execute.c tuvimos problemas para entender como utilizar execvp, tras consultar el sitio web Stack Overflow y la man page pudimos darnos una idea de su uso, la forma en la que aproximamos el problema fue diseccionar un pipeline en 3, el pipe, el scommand y el char. El pipe está compuesto por scommands y el scommand está compuesto por char; si tomamos el primer elemento de pipeline obtendremos un scommand, al cual podemos aplicarle los operadores del TAD scommand; análogamente si tomamos el primer elemento de scommand este será un char, de esta manera tomamos cada elemento de tipo char que sea posterior al primer elemento y lo almacenamos en un arreglo, luego ejecutamos execvp sobre el commando y el arreglo de manera tal que se ejecute correctamente.
	En algunas implementaciones se abusa de los condicionales principalmente como método de defensa ante utilizaciones erróneas del código.
	Algunas librerías a destacar son gmodule.h, con la cual pudimos utilizar GSequence y GSequenceIter para implementar la mayoría de los elementos de los TAD. A su vez unistd.h permitió utilizar chdir para el comando interno "cd". Y por último sys/types.h para utilizar fork.
	Se utilizó algunas veces GDB para el debugging de scommand y pipeline pero no fué la herramienta que nos permitió detectar los errores.
	El código final funciona en un 85% y algunas funciones no se pudieron implementar, principalmente utilizar el resultado de un scommand como entrada del siguiente scommand. Esto principalmente debido a que no logramos comprender como utilizar open() y close() para este fin. Además de nuestra falta de organización para el mismo.
	En conclusión, si bien el laboratorio fue complejo, se pudieron sobrellevar la mayoría de los errores gracias a las consultas y la búsqueda de información en diversos foros, las man pages y la prueba y error. 

